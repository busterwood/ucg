.template on
using System;
.if string(@transaction)
using System.Transactions;
.endif


namespace $(../@cs-namespace)
{
	/// <summary>State machine implementation of $(@name)</summary>
	/// <remarks>GENERATED CODE - any change to this code will be lost when the code is regenerated.</remarks>
	public abstract class $(@name:p)StateMachine	
	{
		public State Current { get; private set; }
		public Exception Exception { get; private set; }
		
		public IsTerminal 
		{ 
			get 
			{
				switch (Current) 
				{
.foreach state[@terminal]
					case $(@name:p):
						return true;
.endfor				
					default:
						return false;
				}
			}
		}

		public void HandleEvent(Event evt)
		{
			bool handled;
			switch (Current) 
			{
.foreach state[not(@terminal) and not(@default)]
				case State.$(@name:p):
					handled = $(@name:p)State(evt);
					break;
.endfor				
				default:
					if (IsTerminal) 
						InvalidEvent(evt); 
					else
						InvalidState();
					return;
			}
.foreach state[@default]
			if (!handled) 
				handled = $(@name:p)State(evt);
			
.endfor
			if (!handled) 
				InvalidEvent(evt); 
		}
.foreach state[not(@terminal)]

		private bool $(@name:p)State(Event evt)
		{
			switch (evt)
			{
.	foreach event
				case Event.$(@on:p):
.	if string(../../@transaction)
					using (var txn = new TransactionScope())
					{
.		foreach do
						Do$(text():p)(evt);
.		endfor
.		if string(@next)
						DoChangeState(State.$(@next:p));
.		endif
						txn.Complete();
					}				
.	else
.		foreach do
					Do$(text():p)(evt);
.		endfor
.		if string(@next)
					DoChangeState(State.$(@next:p));
.		endif
.	endif
					return true;
.	endfor
				default:
					return false;
			}
		}
.endfor		

		private void DoChangeState(State newState)
		{
			if (Current == newState) return;
			Exit(Current);
			ChangeState(newState);
			Enter(Current);
		}

		internal virtual void ChangeState(State newState)
		{
			Current = newState;
		}

		internal virtual void InvalidState() 
		{
			throw new InvalidOperationException($"Invalid state {Current}");
		}

		internal abstract void InvalidEvent(Event evt);
		
		protected virtual void Enter(State st) {}
		
		protected virtual void Exit(State st) {}

		protected virtual void Before(Event evt, Actions act) {}
		
		protected virtual void After(Event evt, Actions act) {}
.foreach distinct-values(.//do)

		private void Do$(text():p)(Event evt)
		{
			Before(evt, Actions.$(text():p));
			$(text():p)();
			After(evt, Actions.$(text():p));
		}

		internal abstract void $(text():p)();
.endfor

		public enum State : byte
		{
.foreach state
			$(@name:p),
.endfor
			Exception, // special error state
		}

		public enum Event : byte
		{
.foreach distinct-values(.//event)
			$(@on:p),
.endfor
			Exception, // special error event
		}

		public enum Actions : byte
		{
.foreach distinct-values(.//do)
			$(text():p),
.endfor
		}
	}
}