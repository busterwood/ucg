.template on
using System;
.if string(@transaction)
using System.Transactions;
.endif

namespace $(../@cs-namespace)
{
	public abstract class $(@name:p)	
	{
		public State Current { get; private set; }

		public async Task RunAsync()
		{
			while (!IsTerminal)
			{
				switch (Current) 
				{
.foreach state[not(@terminal)]
					case $(@name:p):
						await $(@name:p)Async();
						break;
.endfor				
.foreach state[@terminal]
					case $(@name:p):
						break;
.endfor				
					default:
						InvalidState();
						break;
				}
			}
		}

		public IsTerminal 
		{ 
			get 
			{
				switch (Current) 
				{
.foreach state[@terminal]
					case $(@name:p):
						return true;
.endfor				
					default:
						return false;
				}
			}
		}
.foreach state[not(@terminal)]

		public async Task $(@name:p)Async()
		{
			Enter(State.$(@name:p));
			while (Current == State.$(@name:p))
			{
				Event evt = await NextEventAsync();
				switch (evt)
				{
.	foreach event 
					case Event.$(@on:p):
.	if string(../../@transaction)
						using (var txn = new TransactionScope())
						{
.		foreach do
.			if @async
							await Do$(text():p)Async(evt);
.			else
							Do$(text():p)(evt);
.			endif
.		endfor
.		if string(@next)
							ChangeState(State.$(@next:p));
.		endif
							txn.Complete();
						}				
.	else
.		foreach do
.			if @async
						await Do$(text():p)Async(evt);
.			else
						Do$(text():p)(evt);
.			endif
.		endfor
.		if string(@next)
						ChangeState(State.$(@next:p));
.		endif
.	endif
						break;
.	endfor
					default:
						await InvalidEventAsync(evt);
						break;
				}
			}
			Exit(State.$(@name:p));
		}
.endfor		

		internal abstract Task<Event> NextEventAsync();

		internal virtual Task ChangeState(State newState)
		{
			Current = newState;
		}

		internal virtual Task InvalidState() 
		{
			throw new InvalidOperationException($"Invalid state {Current}");
		}

		internal abstract Task InvalidEventAsync(Event evt);
		
		protected virtual void Enter(State st) {}
		
		protected virtual void Exit(State st) {}

		protected virtual void Before(Event evt, Actions act) {}
		
		protected virtual void After(Event evt, Actions act) {}
.foreach distinct-values(.//do)

.	if @async
		private async Task Do$(text():p)Async(Event evt)
		{
			Before(evt, Actions.$(text():p));
			await $(text():p)Async();
			After(evt, Actions.$(text():p));
		}

		internal abstract Task $(text():p)Async()
.	else
		private void Do$(text():p)(Event evt)
		{
			Before(evt, Actions.$(text():p));
			$(text():p)();
			After(evt, Actions.$(text():p));
		}

		internal abstract void $(text():p)();
.	endif
.endfor

		public enum State : byte
		{
.foreach state
			$(@name:p),
.endfor
		}

		public enum Event : byte
		{
.foreach distinct-values(.//event)
			$(@on:p),
.endfor
		}

		public enum Actions : byte
		{
.foreach distinct-values(.//do)
			$(text():p),
.endfor
		}
	}
}